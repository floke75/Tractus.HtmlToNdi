# Paced output buffer behaviour

## Summary
This note explains how the video pipeline behaves when the paced output buffer is enabled versus disabled. When pacing is active the pipeline queues captured frames until the backlog reaches the configured depth, then drains one frame per timer tick. That “bucket” introduces a predictable latency of roughly `BufferDepth / fps` seconds while ensuring the NDI sender presents frames at an even cadence. If the queue dips below the target depth the sender normally repeats the last frame and re-warms before transmitting fresh video again. Operators can opt into a latency-expansion mode (`--allow-latency-expansion`) that keeps playing any queued frames before falling back to repeats, trading temporary extra delay for smoother recovery motion. Optional pacing flags now let Chromium invalidations run in lockstep with the NDI loop, pause capture when the buffer is over-filled, and nudge the pump using cadence-alignment telemetry.

## What drives Chromium renders
Chromium repaints are driven by `FramePump`. In legacy mode the pump wakes on a `PeriodicTimer` whose interval is derived from the configured frame rate, calls `Invalidate` on the browser host, and relies on CefSharp to raise `Paint` callbacks afterwards. A watchdog issues an extra invalidate if paints stop arriving for more than a second.【F:Video/FramePump.cs†L1-L121】

When the pacing switches are enabled the pump acts as an `IChromiumInvalidationScheduler`: it waits for the NDI loop to call `RequestNextInvalidate`, honours pause/resume requests when the buffer is too far ahead, and slews the next deadline by up to half a frame when cadence-alignment telemetry suggests capture is drifting.【F:Video/FramePump.cs†L25-L118】【F:Video/NdiVideoPipeline.cs†L41-L215】 Each `Paint` event is still forwarded to `NdiVideoPipeline.HandleFrame`, which wraps the buffer and hands it to the pipeline.【F:Chromium/CefWrapper.cs†L43-L134】

## Optional pacing and alignment controls

* **Paced invalidation (`--enable-paced-invalidation`)** – When enabled the pipeline requests a single Chromium invalidate after each paced send or repeat so capture stays in lockstep with the NDI cadence. Direct (non-buffered) mode also calls into the scheduler immediately after sending so Chromium never outruns the consumer.【F:Video/NdiVideoPipeline.cs†L122-L215】【F:Video/NdiVideoPipeline.cs†L472-L514】
* **Capture backpressure (`--enable-capture-backpressure`)** – With pacing enabled the pipeline can pause Chromium invalidations whenever the backlog reaches the high watermark or latency debt grows beyond ~1 frame. It resumes once the buffer returns to the target depth (or the integrator goes negative), keeping latency stable without trimming stale frames.【F:Video/NdiVideoPipeline.cs†L41-L215】【F:Video/NdiVideoPipeline.cs†L640-L969】 Telemetry logs `backpressureActive`, plus pause/resume counters, so operators can see when capture was throttled.【F:Video/NdiVideoPipeline.cs†L912-L960】
* **Pump alignment (`--enable-pump-alignment`)** – When both pacing and `--align-with-capture-timestamps` are active the pipeline forwards the latest cadence-alignment delta to the scheduler each tick. The frame pump slews the next invalidate by the requested fraction of a frame so capture cadence converges with the output timeline instead of drifting toward the trimming thresholds.【F:Video/NdiVideoPipeline.cs†L201-L215】【F:Video/NdiVideoPipeline.cs†L878-L969】

All three switches surface via CLI and the launcher UI (“Throttle Chromium invalidation…”, “Pause Chromium when buffer is ahead”, and “Align Chromium pump with capture cadence”) so operators can choose the appropriate mix per deployment. Legacy behaviour remains unchanged unless the flags are toggled.【F:Launcher/LaunchParameters.cs†L14-L153】【F:Launcher/LauncherForm.cs†L15-L246】

## Pipeline behaviour without buffering
When buffering is disabled the pipeline immediately sends each incoming frame. The timestamp for telemetry is taken at send time, and there is no additional pacing loop. As a result, the NDI sender runs at whatever cadence Chromium supplies, which is ultimately controlled by the single `FramePump` timer plus Chromium’s own scheduling.【F:Video/NdiVideoPipeline.cs†L43-L114】

## Pipeline behaviour with buffering enabled
With buffering enabled the following additional steps occur:

1. Every `Paint` copies the pixels into a heap-allocated `NdiVideoFrame`, stamps it with `DateTime.UtcNow`, and enqueues it in a `FrameRingBuffer` (dropping the oldest frame if the bucket is full).【F:Video/NdiVideoFrame.cs†L6-L34】【F:Video/FrameRingBuffer.cs†L5-L77】
2. The pacing task wakes on its own `PeriodicTimer`. While the bucket is filling it does not transmit new frames; once the backlog reaches `BufferDepth` it marks the buffer as primed and sends one frame per tick in FIFO order.【F:Video/NdiVideoPipeline.cs†L116-L181】
3. If the backlog stays below the requested depth for consecutive ticks or the queue is empty, the sender repeats the most recently transmitted frame, increments an underrun counter, and re-enters warm-up until enough fresh frames arrive to restore the desired latency. When `AllowLatencyExpansion` is enabled and there are still queued frames, the pacer continues draining them instead of repeating, and only falls back to repeats once the queue empties.【F:Video/NdiVideoPipeline.cs†L163-L224】
4. When the producer outruns the paced sender and the latency integrator rises above `1`, the pipeline trims stale frames until the backlog falls back to the configured depth (or the high-water mark when latency expansion is active). This keeps latency predictable without bursting output or bouncing back into warm-up.【F:Video/NdiVideoPipeline.cs†L226-L244】
5. Telemetry now surfaces the primed state, live backlog, overflow/stale drops, underruns, warm-up cycles, the duration of the most recent warm-up, (when enabled) latency-expansion sessions/ticks/frames, and pacing/backpressure counters so operators can see how healthy the buffer is at a glance.【F:Video/NdiVideoPipeline.cs†L495-L517】【F:Video/NdiVideoPipeline.cs†L912-L960】

## Latency expectations
Enabling the paced buffer intentionally lags capture by `BufferDepth / fps` seconds. That latency appears when the application starts and after every underrun because the sender waits for the queue to refill before resuming normal transmission. During those warm-up periods the pipeline keeps the NDI cadence steady by repeating the last frame, so downstream receivers never lose the clock even though no fresh video is available. If latency expansion is enabled the pacer will keep playing any queued frames during recovery before switching to repeats, temporarily increasing the effective latency to avoid judder.【F:Video/NdiVideoPipeline.cs†L163-L224】【F:Video/NdiVideoPipeline.cs†L320-L357】

## Implications
* Enabling pacing is a conscious trade-off: operators should size `BufferDepth` to balance acceptable latency against resilience to jitter.【F:Video/NdiVideoPipeline.cs†L116-L181】
* Telemetry consumers should look for `primed`, `buffered`, `underruns`, `warmups`, and `lastWarmupMs` in the log output to understand how the buffer is behaving. The logs also advertise `resyncDrops` whenever stale frames are trimmed due to oversupply and surface `backpressureActive`, `backpressurePauses`, and `backpressureResumes` when pacing controls throttle capture.【F:Video/NdiVideoPipeline.cs†L218-L244】【F:Video/NdiVideoPipeline.cs†L912-L960】
* When buffering is disabled the legacy direct path remains untouched—frames are forwarded immediately with effectively zero additional latency.【F:Video/NdiVideoPipeline.cs†L43-L114】
