# Paced output buffer behaviour

## Summary
This note explains how the video pipeline behaves when the paced output buffer is enabled versus disabled. When pacing is active the pipeline queues captured frames until the backlog reaches the configured depth, then drains one frame per timer tick. That “bucket” introduces a predictable latency of roughly `BufferDepth / fps` seconds while ensuring the NDI sender presents frames at an even cadence. If the queue dips below the target depth the sender normally repeats the last frame and re-warms before transmitting fresh video again. Operators can opt into a latency-expansion mode (`--allow-latency-expansion`) that keeps playing any queued frames before falling back to repeats, trading temporary extra delay for smoother recovery motion.

## What drives Chromium renders
Chromium repaints are driven by the pacing-aware `FramePump`. In legacy periodic mode the pump computes a deadline from the configured frame interval, invalidates the browser host, and a watchdog issues recovery invalidations if paints stop arriving for more than a second. When `EnablePacedInvalidation` is set the pump switches to on-demand mode and waits for the paced sender to request the next slot; it also honours `Pause`/`Resume` so capture backpressure can stop issuing invalidations while the buffer drains.【F:Chromium/FramePump.cs†L1-L214】【F:Video/NdiVideoPipeline.cs†L76-L309】

When pump cadence adaptation is enabled the pipeline forwards the latest capture/output drift and the pump stretches or delays invalidations by up to half a frame to keep capture aligned with the paced sender.【F:Video/NdiVideoPipeline.cs†L188-L210】【F:Chromium/FramePump.cs†L215-L312】 `NdiVideoPipeline` requests an initial burst of invalidations during warm-up and issues one request per pacing tick thereafter so Chromium never outruns the sender cadence.【F:Video/NdiVideoPipeline.cs†L106-L210】 Each `Paint` event is forwarded to `NdiVideoPipeline.HandleFrame`, which wraps the buffer and hands it to the pipeline.【F:Chromium/CefWrapper.cs†L43-L131】

## Pipeline behaviour without buffering
When buffering is disabled the pipeline immediately sends each incoming frame. The timestamp for telemetry is taken at send time, and there is no additional pacing loop. As a result, the NDI sender runs at whatever cadence Chromium supplies, which is ultimately controlled by the single `FramePump` timer plus Chromium’s own scheduling.【F:Video/NdiVideoPipeline.cs†L43-L114】

## Pipeline behaviour with buffering enabled
With buffering enabled the following additional steps occur:

1. Every `Paint` copies the pixels into a heap-allocated `NdiVideoFrame`, stamps it with `DateTime.UtcNow`, and enqueues it in a `FrameRingBuffer` (dropping the oldest frame if the bucket is full).【F:Video/NdiVideoFrame.cs†L6-L34】【F:Video/FrameRingBuffer.cs†L5-L77】
2. The pacing task wakes on its own `PeriodicTimer`. While the bucket is filling it does not transmit new frames; once the backlog reaches `BufferDepth` it marks the buffer as primed and sends one frame per tick in FIFO order.【F:Video/NdiVideoPipeline.cs†L116-L181】
3. If the backlog stays below the requested depth for consecutive ticks or the queue is empty, the sender repeats the most recently transmitted frame, increments an underrun counter, and re-enters warm-up until enough fresh frames arrive to restore the desired latency. When `AllowLatencyExpansion` is enabled and there are still queued frames, the pacer continues draining them instead of repeating, and only falls back to repeats once the queue empties.【F:Video/NdiVideoPipeline.cs†L163-L224】
4. When the producer outruns the paced sender and the latency integrator rises above `1`, the pipeline trims stale frames until the backlog falls back to the configured depth (or the high-water mark when latency expansion is active). This keeps latency predictable without bursting output or bouncing back into warm-up.【F:Video/NdiVideoPipeline.cs†L226-L244】
5. Telemetry now surfaces the primed state, live backlog, overflow/stale drops, underruns, warm-up cycles, capture gate transitions, the duration of the most recent warm-up, and (when enabled) latency-expansion sessions/ticks/frames so operators can see how healthy the buffer is at a glance.【F:Video/NdiVideoPipeline.cs†L504-L517】【F:Video/NdiVideoPipeline.cs†L252-L309】

## Latency expectations
Enabling the paced buffer intentionally lags capture by `BufferDepth / fps` seconds. That latency appears when the application starts and after every underrun because the sender waits for the queue to refill before resuming normal transmission. During those warm-up periods the pipeline keeps the NDI cadence steady by repeating the last frame, so downstream receivers never lose the clock even though no fresh video is available. If latency expansion is enabled the pacer will keep playing any queued frames during recovery before switching to repeats, temporarily increasing the effective latency to avoid judder.【F:Video/NdiVideoPipeline.cs†L163-L224】【F:Video/NdiVideoPipeline.cs†L320-L357】

## Implications
* Enabling pacing is a conscious trade-off: operators should size `BufferDepth` to balance acceptable latency against resilience to jitter.【F:Video/NdiVideoPipeline.cs†L116-L181】
* Telemetry consumers should look for `primed`, `buffered`, `underruns`, `warmups`, `captureGateActive`, `captureGatePauses`, and `captureGateResumes`, plus `lastWarmupMs`, in the log output to understand how the buffer is behaving. When paced invalidation is enabled the logs also expose `pacedPaused`, `pacedOffsetMs`, and `cadenceAdaptation` so operators can confirm whether Chromium is being throttled or stretched to stay in sync with the paced sender. The logs also advertise `resyncDrops` whenever stale frames are trimmed due to oversupply.【F:Video/NdiVideoPipeline.cs†L218-L244】【F:Video/NdiVideoPipeline.cs†L504-L517】
* When buffering is disabled the legacy direct path remains untouched—frames are forwarded immediately with effectively zero additional latency.【F:Video/NdiVideoPipeline.cs†L43-L114】

Operators can opt into the new pacing controls via the CLI (`--enable-paced-invalidation`, `--enable-capture-backpressure`, `--enable-pump-cadence-adaptation`) or matching launcher checkboxes. Disabling switches (`--disable-paced-invalidation`, etc.) keep the legacy behaviour when needed.【F:Launcher/LaunchParameters.cs†L150-L210】【F:Launcher/LauncherForm.cs†L94-L341】【F:README.md†L34-L47】
